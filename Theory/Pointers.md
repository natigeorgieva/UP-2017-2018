Указатели (Pointers)

Указателят е променлива(NВ! има тип!), която съхранява адрес в паметта като стойност. Както променливата от тип int съхранява цяло число, или както променливата от тип bool съхранява true или false, така и указателят съхранява адрес от вида 0x7822221582fc(16-тична бройна система).

Декларация на указател

Указателите се декларират като обикновени променливи, с изключение на това че, се поставя символ * между типа и името на указателя.

    int *iPtr; // указател към променлива от тип int
    double *dPtr; // указател към променлива от тип double
     
    int* iPtr2; // това също е валидно, но го избягвайте
    int * iPtr3; // това също е валидно, но го избягвайте
     
    int *iPtr4, *iPtr5; // два указателя към променливи от тип int

При деклариране на няколко указателя, към всеки указател трябва да бъде сложена нова . *Лесно е да забравите да направите това, ако свикнете да прикрепите звездичката към типа, вместо към името на променливата!

    int * iPtr6, iPtr7; // iPtr6 е указател към int, а iPtr7 е просто обикновен int!

Инициализация

Синтаксис и семантика:

    <object_type> *<object_name_pointer> = &<object_name_transmitter>;

Пример:

    int a = 50;
    int *ptr = &a;

По този начин правим следното: създали сме променлива от тип int и сме я инициализирали със стойност 50, след това създаваме променлива от тип указател към int на когото присвояваме адреса на а. Вземането на адрес на дадена променлива се прави чрез &(както казахме по-горе). Най - важното е да се разбере, че указателите пазят адреса към паметта на това, с което искаме да оперираме.

![title](https://github.com/natigeorgieva/UP-2017-2018/blob/master/Theory/diagrams/MemoryPointer.png)

Пример:

    int a = 50;
    int *ptr = &a;
    
    cout << *ptr << endl; // 50
    cout << ++*ptr << endl; // 51
    cout << a << endl; // 51
    

Нулеви стойности и нулеви указатели

Точно като нормалните променливи, указателите могат да не се инициализират в началото. Ако не е присвоена стойност на указателя, то той ще сочи някой адрес по подразбиране. Освен адресите на паметта, съществува още една допълнителна стойност, която указателят може да съдържа: нулева стойност(null value). Нулевата стойност е специална стойност, която означава, че указателят не сочи нищо/никъде. Ако стойността на указателя е нулевата стойност, то указателят се нарича нулев указател(null pointer).

    int *ptr(0);  // ptr е null pointer
     
    int *ptr2; // ptr2 не е инициализиран
    ptr2 = 0; // ptr2 вече е null pointer

Тъй като нулев указател се оценява с 0, то той може да се използва в условенни изрази и конснтрукции, за да се провери дали указателят е нулев указател или не.

Const

Досега всички указатели, които виждяхме бяха неконстантни указатели към неконстантни стойности:

    int value = 5;
    int *ptr = &value;
    *ptr = 6; // променяме стойността на 6

Какво обаче се случва, ако имаме const int value?

    const int value = 5; // value е константа
    int *ptr = &value; // compile error: cannot convert const int* to int*
    *ptr = 6; // променяме стойността на 6 (невъзможна стъпка)

Горният фрагмент няма да се компилира - не можем да зададем указател без const за стойност c const. Това има смисъл: const value е променлива, чиято стойност не може да бъде променена. Ако можем да зададем неконстантен указател на константна стойност, тогава чрез value-of оператора ще можем да променим стойността. Това би нарушило идеята на const като цяло. Затова има няколко много важни правила кога и как да се използват константи и указатели.

Указател към константа

Указател към константа е неконстантен указател, който сочи към постоянна стойност. Постоянната стойност не може да бъде променяна, независимо дали е дефинирана като константа или променлива.

Синтаксис

    const <type> *<name> = &<value>
    value - е константа или променлива, която не може да променя стойността си чрез указателя
    

Пример:

    const int value = 5;
    const int *ptr = &value; // ptr сочи към "const int"
    *ptr = 6; // Не е позволено, защото сочи към константа

Нека обърнем внимание и на следния пример:

    int value = 5; // value не е константа !!!
    const int *ptr = &value; // ptr сочи към "const int" и все още е валидно
    *ptr = 6; // Не е позволено, защото сочи към константна 
    value = 6; // Обаче е позволено, защото достъпваме променливата чрез нейния идентификатор

Указател към константа може да сочи към неконстантна стойност(променлива). Мислете за това по следния начин: указател към константа се отнася към стойността, като към константа, независимо от това дали първоначално е била определена като константа или променлива.

Тъй като указател към константа не е константен указател(той просто сочи към постоянна стойност), указателя може да бъде пренасочен към други стойности:

    int value1 = 5;
    const int *ptr = &value1; // ptr сочи към "const int"
     
    int value2 = 6;
    ptr = &value2; // okay, сега ptr сочи към нова стойност "const int"

Обобщено: При указател към константа, стойността, към която сочи, не може да бъде променяна чрез указателя.

Константен указател

Също така можем да направим самият указател константен(постоянен). Константният указател е указател, чиято стойност не може да се променя след инициализация. За да декларирате константен указател, използвайте ключовата дума const между * и името на указателя:

Синтаксис:

    <type> *const <name> = &<value>
    value - е променлива
    

Пример:

    int value = 5;
    int *const ptr = &value;

Точно като нормална константа, константния указател трябва да се инициализира със стойност при декларацията си. Това означава, че константният указател винаги ще сочи един и същ адрес. В горния случай ptr винаги ще сочи адреса на value.

    int value1 = 5;
    int value2 = 6;
     
    int * const ptr = &value1; // okay, константния указател ptr е инициализиран с адреса на value1
    ptr = &value2; // not okay, веднъж инициализиран, не може да сочи другаде(да бъде променян)

Въпреки това, тъй като стойността, към която сочи, все още не е константа, е възможно да се промени стойността, която се сочи.

    int value = 5;
    int *const ptr = &value; // ptr винаги ще сочи към адреса на value
    *ptr = 6; // позволено, сочи към променлива

Обобщено: При константен указател, адреса, който той съхранява, не може да бъде променян. Но стойността на клетката с този адрес може да бъде променяна.

Константен указател към константа

И най-накрая, възможно е да се дефинира константен указател към константна стойност с помощта на ключовата дума const, както преди типа, така и преди името на променливата:

Синтаксис

    const <type> *const <name> = &<value>
    value - е константа или променлива, която не може да променя стойността си чрез указателя
    

Пример:

    int value = 5;
    const int *const ptr = &value;

Константния указател към константа не може да бъде пренасочен към друг адрес, нито пък стойността, която сочи, да бъде променена чрез указателя(независимо дали сочи константа или променлива).

Обобщено: При константен указател към константа, адресът и стойността на клетката не могат да бъдат променяни.

Трябва само да запомните 4 правила и те са доста логични:

- Неконстантен указател, може да бъде пренасовчан към други адреси
- Константният указател, сочи към един и същ адрес, и този адрес не може да бъде променян
- На указател към неконстантна стойност може да се променя стойността, която той сочи. Те не могат да сочат към константа.
- Указател към константна стойност се отнася към стойността като към константа(дори и да не е), и по този начин не може да се промени стойността, която те сочат.

   int value = 5;
   
   const int *ptr1 = &value; // ptr1 сочи към "const int", това е указател към константа
    
   int *const ptr2 = &value; // ptr2 сочи към "int", това е константен указател, към неконстантна стойност(променлива)
    
   const int *const ptr3 = &value; // ptr3 сочи към "const int", това е константен указател към константа
